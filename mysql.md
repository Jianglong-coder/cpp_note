# mysql命令行

```sql
mysql -V/--version       			查看mysql版本
sudo service mysql start  			开启服务
sudo service mysql restart  		重启服务
sudo service mysql stop  			关闭服务
systemctl status mysql   			查看mysql状态
mysql -u root -p         			登录root 我的密码为123456
exit;								退出
use mysql;							选择数据库
select user,host from mysql.user;	查看mysql用户与主机权限
source [script file];         		执行脚本，脚本名要包含路径
select database();        			查看当前库
show databases;           			展示所有库
create database [database name];    创建数据库
show tables;						展示表
show columns from customers;        展示表列
describe customers;					是show columns的快捷方式
show status; 						显示服务器状态信息
show create database;				
show grants;						显示授予用户
show errors;						显示错误
show warnings;						显示警告
```

# MySQL实战45讲

## 26. 备库为什么会延迟好几个小时？

如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级别。而且对于一个压力持续比较高的主库来说，备库很可能永远都追不上主库的节奏。

## 27. 主库出问题了，从库怎么办？

大多数场景都是一主多从结构，如下图。A为主库，A’为备库，BCD为从库。主库负责读写，从库负责读。

<img src="./assets/image-20240523164347092.png" alt="image-20240523164347092" style="zoom: 50%;" />

**基于位点的主备切换：**

主库发生故障后，A‘成为新的主库，从库BCD要改接到A’。原来节点 B 是 A 的从库，本地记录的也是 A 的位点。但是相同的日志，A 的位点和 A’的位点是不同的。因此需要先找同步位点。找位点时会找一个稍微往前的位置，当A宕机时，某一行binlog在从库B和A‘上都已经存在了，A’会把这行发给B执行，此时可能会发生冲突(一般为两种：插入数据时唯一键冲突，删除数据时找不到行)，需要手动跳过，也可以设置slave_skip_errors参数跳过，同步完成后要把参数调回来。

**GTID MySQL 5.6 版本引入了 GTID，彻底解决了这个困难。Global Transaction Identifier，也就是全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是`GRTID=server_uuid:gno`，server_uuid 是一个实例第一次启动时自动生成的，是一个全局唯一的值；gno 是一个整数，初始值是 1，每次提交事务的时候分配给这个事务，并加 1。在GTID模式下，每个事务都会跟一个GTID一一对应。每个 MySQL 实例都维护了一个 GTID 集合，用来对应“这个实例执行过的所有事务”。

GTID的主备切换逻辑：在实例B上执行start slave命令，取binglog的逻辑是这样的：

1.  实例 B 指定主库 A’，基于主备协议建立连接。
2. 实例 B 把 set_b 发给主库 A’。
3. 实例 A’算出 set_a 与 set_b 的差集，也就是所有存在于 set_a，但是不存在于 set_b的 GTID 的集合，判断 A’本地是否包含了这个差集需要的所有 binlog 事务。
   - 如果不包含，表示 A’已经把实例 B 需要的 binlog 给删掉了，直接返回错误；
   - 如果确认全部包含，A’从自己的 binlog 文件里面，找出第一个不在 set_b 的事务，发给 B；

4. 之后就从这个事务开始，往后读文件，按顺序取 binlog 发给 B 去执行。

## 28. 读写分离有哪些坑？

<img src="./assets/image-20240523164347092.png" alt="image-20240523164347092" style="zoom: 50%;" />

读写分离目的是分摊主库压力，上图是客户端主动做负载均衡。还有一种架构是在mysql和客户端之间添加中间代理层proxy。

<img src="./assets/image-20240524154243022.png" alt="image-20240524154243022" style="zoom: 50%;" />

以上两种共有问题：主从延迟：客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到事务更新之前的状态。文章中成为过期读。

**处理过期读的集中方案：**

- **强制走主库方案：**对读请求分类，要求必须拿到最新结果的走主库，可以读到旧数据的走从库。这个方案最多。
- **sleep 方案：**大部分主备延迟在1秒内，在主库更新后，读从库前sleep1秒。但是有问题，如果请求为0.5秒也要等1秒，如果延迟超过1秒，还会过期读。
- **判断主备无延迟方案：**1. 判断seconds_behind_master是否等于0，但是参数是按秒来的，不精准  2. 对比位点确保主备无延迟   3. 对比GTID集合确保主备无延迟，对比备库收到的如有日志的GTID集合，和备库所有已经执行完成的GTID集合。但是不完全精准，如果主库收到了事务执行完了返回给客户端了，但是还没发给从库，此时在从库读不到。
- **配合 semi-sync 方案：**这个用来配合前一个方案。半同步复制：事务提交时，主库把binlog发给从库，从库收到后回ack表示收到，主库收到ack后才能给客户端回事务完成的确认。但是也有问题，在一主多从，还是有过期读(因为只等了一个从库的ack)，或者可能一直有延迟，一直等待。
- **等主库位点方案：**
- **等 GTID 方案：**

**等主库位点方案：**

其实在客户端在发完trx1更新后发起的select语句，只需要确保trx1执行完成就可以执行select语句了，不用等到主备无延迟的情况，因为可能trx1在备库已经完成了，但是主备之间一直有延迟，导致等不到无延迟的情况。

1. 在主库中trx1 事务更新完成后，马上执行 `show master status` 得到当前主库执行到的 File 和Position；

2. 选定一个从库执行查询语句；
3. 在从库上执行 `select master_pos_wait(File, Position, 1)`；
4. 如果返回值是 >=0 的正整数，则在这个从库执行查询语句；
5. 否则，到主库执行查询语句。

<img src="./assets/image-20240525150350836.png" alt="image-20240525150350836" style="zoom:50%;" />



**等GTID方案：**

如果数据库开启了GTID模式，也有等GTID方案。与等主库位点方案一致。

1. 在主库中trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；
2. 选定一个从库执行查询语句；
3. 在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；
4. 如果返回值是 0，则在这个从库执行查询语句；
5. 否则，到主库执行查询语句。

在实际应用中，这几个方案是可以混合使用的。比如先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等 GTID 或等位点的方案。过期读在本质上是由一写多读导致的。在实际应用中，可能会有别的不需要等待就可以水平扩展的数据库方案，但这往往是用牺牲写性能换来的，也就是需要在读性能和写性能中取权衡。

## 29. 如何判断一个数据库是不是出问题了？

主备切换有两种场景，一种是主动切换，一种是被动切换。而其中被动切换，是因为主库出问题了，由 HA 系统发起的。所以怎么判断一个主库出问题了？
